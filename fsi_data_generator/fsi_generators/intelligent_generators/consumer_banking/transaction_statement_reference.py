from data_generator import DataGenerator, SkipRowGenerationError
from typing import Any, Dict


def generate_random_transaction_statement_reference(id_fields: Dict[str, Any], dg: DataGenerator) -> Dict[str, Any]:
    """
    Generate a random transaction statement reference with plausible values.

    Args:
        id_fields: Dictionary containing the required ID fields
        dg: DataGenerator instance

    Returns:
        Dictionary containing randomly generated transaction statement reference data
    """
    # Get database connection
    conn = dg.conn

    # Validate required fields
    if 'consumer_banking_transaction_id' not in id_fields:
        raise ValueError("consumer_banking_transaction_id is required")

    # Fetch the transaction to verify it exists and get transaction date
    cursor = conn.cursor()
    try:
        cursor.execute("""
            SELECT t.consumer_banking_transaction_id, t.transaction_date, 
                   t.consumer_banking_account_id
            FROM consumer_banking.transactions t
            WHERE t.consumer_banking_transaction_id = %s
        """, (id_fields['consumer_banking_transaction_id'],))

        transaction = cursor.fetchone()

        if not transaction:
            raise ValueError(f"No transaction found with ID {id_fields['consumer_banking_transaction_id']}")

        # Get the transaction's date and account ID
        transaction_date = transaction.get('transaction_date')
        account_id = transaction.get('consumer_banking_account_id')

        # Find a matching statement based on the transaction date
        # Transaction should be within the statement period
        cursor.execute("""
            SELECT s.consumer_banking_statement_id, s.statement_reference
            FROM consumer_banking.statements s
            WHERE s.consumer_banking_account_id = %s
            AND s.start_date_time <= %s::timestamptz
            AND s.end_date_time >= %s::timestamptz
            ORDER BY s.end_date_time DESC
            LIMIT 1
        """, (account_id, transaction_date, transaction_date))

        statement = cursor.fetchone()

        # If no matching statement is found, the transaction might be new
        # and will be included in a future statement
        if not statement:
            raise SkipRowGenerationError

        # Extract the statement reference
        statement_reference = statement.get('statement_reference')

        # Create the transaction statement reference dictionary
        transaction_statement_reference = {
            "consumer_banking_transaction_statement_reference_id": None,  # Will be generated by the database
            "consumer_banking_transaction_id": id_fields['consumer_banking_transaction_id'],
            "statement_reference": statement_reference
        }

        return transaction_statement_reference

    finally:
        cursor.close()
